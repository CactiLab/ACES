# ACES Code Analyzis

> This is a document to analyze the ACES code or process.

## Staring from the setups

With the help of setup steps from <https://github.com/CactiLab/ACES/blob/master/Readme.md>, combining with ACES paper to understand how it works.

### Makefile for test_projects

According to <https://github.com/baoshi/CubeMX2Makefile>, the `CubeMX2Makefile.py` in `repo_root/compiler/tools` is trying to create the Makefile for the specific STM project automatically.

This script utilize `.cproject` file to setup the environment the STM project needs, such as the link script, include files, etc. You can define the library or other tools you need in this script. 

>If you have the experience to load .cproject in TrueStdio IDE, it would be better to understand. Now we do not need those kind of IDE, ACES builds the project by gcc toolchain.

The generated Makefile includes (listed the important ones):

- gcc path, llvm path,
- hexbox library (hexbox-rt-lib): (Section 5.4) this library help to configure the MPU region 
- hexbox graph tool corresponds to `compiler/graph_analysis/analyzer.py`.

  - (Section 5.1) Uses the PDG and a device description to create an **initial region graph**. The region graph is a directed graph that captures the grouping of functions, global data, and peripherals into MPU regions. `line819: PDG=build_graph(args.json_graph)`
  - (Section 5.2) Peripherals are **merged** using the deivice decsription to build a tree of all the possible valid MPU regions the cover the device peripherals: `line820: get_device_desc(args.board)`, this function is in `device.py` file (build a tree of MPU regions that cover the peripherals).
    - `line162: build_mpu_region_tree(desc)`, desc is the sorted peripherals.
  - Then the final region graph is exported as a **JSON file** to `??/.build/hexbox`.

- hexbox final link tool corresponds to `final_linker_gen.py`.
  - (Section 5.4) This is to generate the second link script to protect the stack : previous link script is used to create the white-list. New link script is stored in `??/.build/hexbox`.
    - With the help of `setup_asm_and_ld.py` file, ACES adds comments to declaim the `line118 <HEXBOX_TEXT_SECTION>` and `line187: <HEXBOX_DATA_SECTIONS>` in the **original link script**. 
    - Then replace those two sections with the regions provided by the **JSON file** in the intermediate link file.
    - After recording all required address when running, generate the **final link script**. This because MPU region must be a power of two in size and the starting address must be a multiple of its size. But somes code and data regions are not meet this requirement, so use link script to create the white-list for those data and code regions. 

- hexbox result tool corresponds to `collect_results.py`.
  - (Section 6. Evaluation)

The Makefile will build the project based on the optimization policy we set.


### Build application 

> record data and code regions to generate the white-list

```bash
${REPO_ROOT}/compiler/tools/build_record.sh
```

This command should run in the project folder, inside this script:

```bash
#!/bin/bash
set -x

declare -a arr=("peripheral"
                "filename"
                "filename-no-opt"
                )


for i in "${arr[@]}"
do
  make all HEXBOX_METHOD=$i >$i_final.log 2>$i_final.log
done
```

Based on ACES paper, there are three optimazation policies (two are based on filename):

- peripheral: isolates peripherals from each other
- filename: merges all code regions with identical data and peripheral dependencies, reducing compartment transitions at runtime without changing data accessible to any compartment
- filename-no-optimization: a naive policy that demonstrates the versality of the policies ACES can apply, and pitfalls of such a policy

After this command, will generate:

- `.build` folder: including some object files, region memory mapping file.
- `.build/hexbox` folder: JSON files to describe the call graph, link scripts.
- `bin` folder: each policy has its own origin, hexbox intermedia, record `.o, .bc, .elf` file
- `.dot` files.

### Run the application

```bash
APP_NAME=FatFs-uSD ~/Downloads/ACES-master/compiler/tools/build_final.sh record run
```

Load those `.elf` files generated by previoud steps to the board, using gdb and python script to connect the board. `gdb_record.py` corresponds with record option, `memory_reader.py` is used for different polices, `gdb_run.py` corresponds with run option.

> Actually, those python scripts are used to show the information of each region.

### Extension



#### New IRs

- `SelectionDAGBuilder.cpp`:

#### New passes

- ``

#### New backends

### Python tools with gdb

#### gdb_record.py

#### memory_reader.py

#### gdb_run.py