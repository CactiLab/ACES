LLVM Cook Book: <chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/assets/pdf/web/viewer.html?file=https%3A%2F%2Forg.computer%2Fdist%2Fpdf%2Fllvm-cookbook.pdf>

Sample code: <https://github.com/elongbug/llvm-cookbook>

# Chapter 1

## Modular design

`opt`

Optimize the statement in functions, combining the instructions:

```shell
$ opt –S –instcombine testfile.ll –o output1.ll
```

Dead argument elimination optimization:

```shell
$ opt –S –deadargelim testfile.ll –o output2.ll
```

## Converting c source code to LLVM assembly

`clang`

Generate LLVM IR from C code:

```shell
$ clang -emit-llvm -S multiply.c -o multiply.ll
```

Use `ccl` for generating IR
```shell
$ clang -ccl -emit-llvm testfile.c -o testfile.ll
```

## Converting IR to LLVM bitcode

`llvm-as` is the LLVM assembler. It converts the LLVM assembly file from IR to bitcode.

```shell
$ llvm-as test.ll -o test.bc
$ hexdump -C test.bc
```

## Converting LLVM bitcode to target machine assembly

`llc`

```shell
$ llc test.bc -o test.s
```
`test.s` is the assembly code.

Or use Clang front end to generate the assembly code:
```shell
$ clang -S test.bc -o test.s –fomit-frame-pointer
```
We use the additional option fomit-frame-pointer , as Clang by default does not eliminate the frame pointer whereas llc eliminates it by default

### Setting Arch and CPU

```shell
-march=architecture flag
-mcpu=cpu flag
-regalloc=basic/greedy/fast/pbqp
```

## Converting LLVM bitcode back to LLVM assembly

`llvm-dis`

```shell
$ llvm-dis test.bc -o test.ll
```

## Transforming LLVM IR

```shell
$ opt -passname input.ll -o output.ll
For example:
$ opt -mem2reg -S multiply.ll -o multiply1.ll
```

When the `–analyze` option is passed to `opt`, it performs various analyses of the input source
and prints results usually on the standard output or standard error. Also, the output can be
redirected to a file when it is meant to be fed to another program.
When the `–analyze` option is not passed to opt, it runs the transformation passes meant to
optimize the input file.

Important transformations:

- adce : Aggressive Dead Code Elimination
- bb-vectorize : Basic-Block Vectorization
- constprop : Simple constant propagation
- dce : Dead Code Elimination
- deadargelim : Dead Argument Elimination
- globaldce : Dead Global Elimination
- globalopt : Global Variable Optimizer
- gvn : Global Value Numbering
- inline : Function Integration/Inlining
- instcombine : Combine redundant instructions
- licm : Loop Invariant Code Motion
- loop : unswitch: Unswitch loops
- loweratomic : Lower atomic intrinsics to non-atomic form
- lowerinvoke : Lower invokes to calls, for unwindless code generators
- lowerswitch : Lower SwitchInsts to branches
- mem2reg : Promote Memory to Register
- memcpyopt : MemCpy Optimization
- simplifycfg : Simplify the CFG
- sink : Code sinking
- tailcallelim : Tail Call Elimination

## Linking LLVM bitcode

`llvm-link`

```shell
$ clang -emit-llvm -S test1.c -o test1.ll
$ clang -emit-llvm -S test2.c -o test2.ll
$ llvm-as test1.ll -o test1.bc
$ llvm-as test2.ll -o test2.bc
```

`llvm-link` only links bitcode files.

## Executing LLVM bitcode

`lli`

```shell
$ lli output.bc
```

`lli` command executes the program present in LLVM bitcode format by using a jsut-in-time compiler, if there is one available for the architecture, or an interpreter.

## Using the C frontend Clang

`Clang` tool

```shell
$ clang test.c
```

`Clang` can be used in preprocessor only mode by providing the `-E` flag. If we use 
```c
#define MAX 100

int a[MAX]
```
After compiling,
```shell
$ clang test.c -E
```
It turns out:
```c
int a[100]
```
### Print the AST

`clang` can also be used to print the AST (`-ccl` option ensures that only the compiler front-end should be run, not the driver, and it prints the AST corresponding to the test.c file code):
```shell
clang -ccl test.c -ast-dump
```

### Generate LLVM assembly
Or using `clang` to generate the LLVM assembly (`-S` and `-emit-llvm` flag ensure the LLVM assembly is generated for the test.c code):
```shell
$ clang test.c -S -emit-llvm -o -
```

### Generate Machine Code

It generates the output on standard output because of the option `-o -`:
```shell
$ clang -S test.c -o -
```

When the `-S` flag is used alone, machine code is generated by the code generation process of the compiler.

## Using the GO frontend, DragonEgg, 

...

# Chapter 2: Steps in Writing a Frontend

A TOY langugage is used to demonstrate how a lexer and a parser can be implemented.

# Chapter 3
...

# Chapter 4: Preparing Optimizations

> After the source code is compiled to IR, it can be optimized into more effective code. A pass serves the purpose of optimizing LLVM IR. 
A pass runs over the LLVM IR, processes the IR, analyzes it, identifies the optimization opportunities, and modifies the IR to produce optimized code.

`opt` is used to run optimization passes on LLVM IR.

Converts the C into LLVM IR first:
```shell
$ clang -S -O0 -emit-llvm example.c
```

Different opt levels:
```shell
$ opt -O0 -S example.ll // this is not provided in my version of llvm (4.0)
$ opt -O1 -S example.ll
$ opt -O2 -S example.ll
$ opt -O3 -S example.ll
```

## Writing your own LLVM pass

A pass is an instance of the Pass LLVM class.

